diff --git a/src/kr/ac/kaist/jsaf/nodes_util/JSAstToConcrete.scala b/src/kr/ac/kaist/jsaf/nodes_util/JSAstToConcrete.scala
index 1464304..d0f5892 100644
--- a/src/kr/ac/kaist/jsaf/nodes_util/JSAstToConcrete.scala
+++ b/src/kr/ac/kaist/jsaf/nodes_util/JSAstToConcrete.scala
@@ -127,6 +127,11 @@ object JSAstToConcrete extends Walker {
     decreaseIndent
   }
 
+  class StringBuilderHelper(s: StringBuilder) {
+    def toStringP() = new StringBuilder("(").append(s.toString).append(")").toString
+  }
+  implicit def stringBuilderWrapper(s: StringBuilder) = new StringBuilderHelper(s)
+
   /* The rule of separators(indentation, semicolon and newline) in unparsing pattern matchings.
    * This rule is applied recursively
    * Principle: All case already has indentation at the front and newline at the end.
@@ -151,7 +156,18 @@ object JSAstToConcrete extends Walker {
       val s: StringBuilder = new StringBuilder
       s.append(walk(info))
       s.append("[")
-      elements.foreach(e => s.append(walk(e)).append(", "))
+      elements match {
+        case Nil => ()
+        case head :: tail =>
+          head match {
+            case Some(e) => s.append(walk(e))
+            case None => s.append("undefined")
+          }
+          tail.foreach(_ match {
+            case Some(e) => s.append(", ").append(walk(e))
+            case None => s.append(", ").append("undefined")
+          })
+      }
       s.append("]")
       s.toString
     case SArrayNumberExpr(info, elements) =>
@@ -167,7 +183,7 @@ object JSAstToConcrete extends Walker {
       s.append(walk(lhs)).append(" ")
       s.append(walk(op)).append(" ")
       s.append(walk(right))
-      s.toString
+      s.toString /*P*/
     case SBlock(info, stmts, _) =>
       val s: StringBuilder = new StringBuilder
       s.append(walk(info))
@@ -192,7 +208,7 @@ object JSAstToConcrete extends Walker {
       val s: StringBuilder = new StringBuilder
       s.append(walk(info))
       s.append(walk(obj)).append("[").append(walk(index)).append("]")
-      s.toString
+      s.toString /*P*/
     case SBreak(info, target) =>
       val s: StringBuilder = new StringBuilder
       s.append(walk(info))
@@ -225,7 +241,7 @@ object JSAstToConcrete extends Walker {
       val s: StringBuilder = new StringBuilder
       s.append(walk(info))
       s.append(walk(cond)).append(" ? ").append(walk(trueBranch)).append(" : ").append(walk(falseBranch))
-      s.toString
+      s.toString /*P*/
     case SContinue(info, target) =>
       val s: StringBuilder = new StringBuilder
       s.append(walk(info))
@@ -252,12 +268,18 @@ object JSAstToConcrete extends Walker {
     case SDot(info, obj, member) =>
       val s: StringBuilder = new StringBuilder
       s.append(walk(info))
-      s.append(walk(obj)).append(".").append(walk(member))
-      s.toString
+      obj match {
+        case SDoubleLiteral(_,_,_) =>
+          s.append("(").append(walk(obj)).append(")")
+        case _ =>
+          s.append(walk(obj))
+      }
+      s.append(".").append(walk(member))
+      s.toString /*P*/
     case SEmptyStmt(info) =>
       val s: StringBuilder = new StringBuilder
       s.append(walk(info))
-      s.append(";")
+      s.append("undefined;")
       s.toString
     case SExprList(info, exprs) =>
       join(exprs, ", ", new StringBuilder(walk(info))).toString
@@ -272,7 +294,7 @@ object JSAstToConcrete extends Walker {
       s.append(walk(prop)).append(" : ").append(walk(expr))
       s.toString
     case SDoubleLiteral(info, text, num) =>
-      walk(info)+text
+      walk(info)+ /*text*/ num.toString().replace('E','e');
     case SFor(info, init, cond, action, body) =>
       val s: StringBuilder = new StringBuilder
       s.append(walk(info))
@@ -329,7 +351,7 @@ object JSAstToConcrete extends Walker {
       s.append(walk(fun)).append("(")
       s.append(join(args, ", ", new StringBuilder("")))
       s.append(")")
-      s.toString
+      s.toString /*P*/
     case SFunDecl(info, SFunctional(fds, vds, body, name, params), _) =>
       val s: StringBuilder = new StringBuilder
       s.append(walk(info))
@@ -349,7 +371,7 @@ object JSAstToConcrete extends Walker {
       s.append(") \n").append(getIndent).append("{\n")
       prFtn(s, fds, vds, toList(body.getBody))
       s.append("\n").append(getIndent).append("})")
-      s.toString
+      s.toString /*P*/
     case SGetProp(info, prop, SFunctional(fds, vds, body, _, _)) =>
       val s: StringBuilder = new StringBuilder
       s.append(walk(info))
@@ -367,16 +389,18 @@ object JSAstToConcrete extends Walker {
       val s: StringBuilder = new StringBuilder
       s.append(walk(info))
       var oneline: Boolean = isOneline(trueBranch)
-      s.append("if(").append(walk(cond)).append(")\n")
+      s.append("if(").append(walk(cond)).append(") {\n")
       if(oneline) increaseIndent
       s.append(getIndent).append(walk(trueBranch))
       if(oneline) decreaseIndent
+      s.append("}")
       if(falseBranch.isSome){
         oneline = isOneline(falseBranch)
-        s.append("\n").append(getIndent).append("else\n")
+        s.append("\n").append(getIndent).append("else {\n")
         if(oneline) increaseIndent
         s.append(getIndent).append(walk(falseBranch))
         if(oneline) decreaseIndent
+        s.append("}")
       }
       s.toString
     case SInfixOpApp(info, left, op, right) =>
@@ -385,11 +409,13 @@ object JSAstToConcrete extends Walker {
       s.append(walk(left)).append(" ")
       s.append(walk(op)).append(" ")
       s.append(walk(right))
-      s.toString
+      s.toStringP
     case SIntLiteral(info, intVal, radix) =>
       val str = radix match {
+        /*
         case 8 => "0" + intVal.toString(8)
         case 16 => "0x" + intVal.toString(16)
+        */
         case _ => intVal.toString
       }
       walk(info)+str
@@ -404,7 +430,7 @@ object JSAstToConcrete extends Walker {
       val s: StringBuilder = new StringBuilder
       s.append(walk(info))
       s.append("new ").append(walk(lhs))
-      s.toString
+      s.toString /*P*/
     case SNull(info) =>
       walk(info)+"null"
     case SObjectExpr(info, members) =>
@@ -424,7 +450,7 @@ object JSAstToConcrete extends Walker {
       val s: StringBuilder = new StringBuilder
       s.append(walk(info))
       s.append(walk(op)).append(" ").append(walk(right))
-      s.toString
+      s.toString /*P*/
     case SProgram(info, STopLevel(fds, vds, program)) =>
       val s: StringBuilder = new StringBuilder
       prFtn(s, fds, vds, NU.toStmts(program))
@@ -509,7 +535,7 @@ object JSAstToConcrete extends Walker {
       val s: StringBuilder = new StringBuilder
       s.append(walk(info))
       s.append(walk(lhs)).append(" ").append(walk(op))
-      s.toString
+      s.toString /*P*/
     case SVarDecl(info, name, expr, _) =>
       val s: StringBuilder = new StringBuilder
       s.append(walk(info))
diff --git a/src/kr/ac/kaist/jsaf/nodes_util/NodeFactory.scala b/src/kr/ac/kaist/jsaf/nodes_util/NodeFactory.scala
index 4c8f0c5..3517f3c 100644
--- a/src/kr/ac/kaist/jsaf/nodes_util/NodeFactory.scala
+++ b/src/kr/ac/kaist/jsaf/nodes_util/NodeFactory.scala
@@ -356,7 +356,7 @@ object NodeFactory {
     if (elmts.size > 1000)
       new ArrayNumberExpr(makeSpanInfoComment(span), elmts)
     else
-      makeArrayExpr(span, toJavaList(toList(elmts).map(e => some(makeDoubleLiteral(span, e.toString, e).asInstanceOf[Expr]))))
+      makeArrayExpr(span, toJavaList(toList(elmts).map(e => some(makeNumericLiteral(span, e.toString, e).asInstanceOf[Expr]))))
   }
 
   def makeArrayExpr(span: Span, elmts: JList[JOption[Expr]]) =
@@ -426,6 +426,11 @@ object NodeFactory {
     JDouble.valueOf(beforeDot)
   }
 
+  def makeNumericLiteral(span: Span, str: String, doubleVal: Double) =
+    if (str.endsWith(".0"))
+      new IntLiteral(makeSpanInfoComment(span), new BigInteger(str.substring(0, str.length-2), 10), 10)
+    else new DoubleLiteral(makeSpanInfoComment(span), str, doubleVal)
+
   def makeIntLiteral(span: Span, intVal: BigInteger, radix: Int = 10) =
     new IntLiteral(makeSpanInfoComment(span), intVal, radix)
 
diff --git a/src/kr/ac/kaist/jsaf/nodes_util/Unprinter.java b/src/kr/ac/kaist/jsaf/nodes_util/Unprinter.java
index 96d6e79..5f050eb 100644
--- a/src/kr/ac/kaist/jsaf/nodes_util/Unprinter.java
+++ b/src/kr/ac/kaist/jsaf/nodes_util/Unprinter.java
@@ -257,7 +257,12 @@ public class Unprinter extends NodeReflection {
                 } else if (f.getType() == BigInteger.class) {
                     f.set(node, readBigInteger(l.name()));
                 } else if (f.getType() == Double.class) {
-                    f.set(node, readDouble(l.name()+"."+lexAfter(".")));
+                    String n = l.name();
+                    if (n.equals("Infinity")) {
+                        f.set(node, readDouble(n));
+                    } else {
+                        f.set(node, readDouble(n+"."+lexAfter(".")));
+                    }
                 } else if (Option.class.isAssignableFrom(f.getType())) {
                     f.set(node, readOption());
                 } else if (ASTSpanInfo.class.isAssignableFrom(f.getType())) {
diff --git a/src/kr/ac/kaist/jsaf/parser/Declaration.rats b/src/kr/ac/kaist/jsaf/parser/Declaration.rats
index 78985f6..5787cbb 100644
--- a/src/kr/ac/kaist/jsaf/parser/Declaration.rats
+++ b/src/kr/ac/kaist/jsaf/parser/Declaration.rats
@@ -23,14 +23,11 @@ import Spacing;
  * Program ::= w SourceElements? w EndOfFile
  */
 public Program File =
-     initParser a1:UseStrictDirectives? w a2:TopLevelSourceElements? closeParser
+     initParser a2:TopLevelSourceElements? closeParser
      { Span span = createSpan(yyStart,yyCount);
        if (a2 == null) a2 = Collections.<SourceElement>emptyList();
        HashMap<String, Span> map = new HashMap<String, Span>();
-       if (a1 == null)
            yyValue = NodeFactory.makeProgram(span, a2, false);
-       else
-           yyValue = NodeFactory.makeProgram(span, a2, true);
      };
 void initParser = w { initParser(); };
 void closeParser = w EndOfFile
@@ -287,19 +284,14 @@ public List<Id> Params =
  * FunctionBody ::= { w SourceElement* w }
  */
 public kr.ac.kaist.jsaf.useful.Pair<List<SourceElement>, Boolean> FunctionBody =
-     opencurly w a1:UseStrictDirectives? w closecurly
-     { if (a1 == null)
+     opencurly w closecurly
+     { 
          yyValue = new kr.ac.kaist.jsaf.useful.Pair<List<SourceElement>, Boolean>(Collections.<SourceElement>emptyList(),
                                                                                   Boolean.valueOf(false));
-       else
-         yyValue = new kr.ac.kaist.jsaf.useful.Pair<List<SourceElement>, Boolean>(Collections.<SourceElement>emptyList(),
-                                                                                  Boolean.valueOf(true));
      }
-   / opencurly w a1:UseStrictDirectives? w a2:SourceElements w closecurly
-     { if (a1 == null)
+   / opencurly w a2:SourceElements w closecurly
+     { 
           yyValue = new kr.ac.kaist.jsaf.useful.Pair<List<SourceElement>, Boolean>(a2, Boolean.valueOf(false));
-       else
-          yyValue = new kr.ac.kaist.jsaf.useful.Pair<List<SourceElement>, Boolean>(a2, Boolean.valueOf(true));
      };
 
 /*
diff --git a/src/kr/ac/kaist/jsaf/parser/Statement.rats b/src/kr/ac/kaist/jsaf/parser/Statement.rats
index f09a653..1dabfdf 100644
--- a/src/kr/ac/kaist/jsaf/parser/Statement.rats
+++ b/src/kr/ac/kaist/jsaf/parser/Statement.rats
@@ -72,7 +72,8 @@ public Stmt Statement =
        yyValue = NodeFactory.makeEmptyStmt(span);
      }
 // !(opencurly) a1:Expression EOS // !(opencurly / function) a1:Expression EOS
-   / a1:Expression EOS // !(opencurly / function) a1:Expression EOS
+// a1:Expression EOS // !(opencurly / function) a1:Expression EOS
+   / !(function) a1:Expression EOS
      { Span span = createSpan(yyStart,yyCount);
        yyValue = NodeFactory.makeExprStmt(span, a1);
      }
